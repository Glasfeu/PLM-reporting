#+TITLE: Stage 2015 - Journal de bord
#+AUTHOR: Alexandre CARPENTIER
#+DATE: lundi 15 juin 2015

* Week 15 Jun
** Mon 15 Jun

- Premières modifications du code des classes réalisées lors du PIDR
- Création d'une classe à part qui réalise le travail qui était fait avant dans le Harvester (version avec objets)

*** DONE Modifier le code du Harvester pour l'intégrer au travail déjà effectué
     SCHEDULED: <2015-06-17 wed.>
*** DONE Retirer de la liste les clics rageurs sur Run quand du code ne fonctionne pas
     SCHEDULED: <2015-06-18 thu.>
*** DONE Vérifier le bon fonctionnement du Harvester et des nouvelles méthodes afin d'être sûr que l'on récupère bien les bonnes erreurs
     SCHEDULED: <2015-06-22 mon.>

** Tue 16 Jun

- Correction de quelques bugs dans les ré-exécutions de codes élève
- Réimplémentation de la classe de statistiques (on oublie le csv pour l'instant, étant donné qu'il y a des virgules dans les logs d'erreur)

*** DONE Résoudre le problème des codes Python qui font des erreurs d'interprétation (affiche "null" pour le moment)
      SCHEDULED: <2015-06-18 thu.>
*** DONE Finir les tests éventuels (clics rageurs, fonctionnement global)
      SCHEDULED: <2015-06-19 fri.>
*** DONE Finir l'intégration avec le code d'Hervé
      SCHEDULED: <2015-06-19 fri.>
*** DONE Etudier le cas des boucles infinies dans le code élève
      SCHEDULED: <2015-06-22 mon.>

** Wed 17 Jun

- Jabber fonctionne sur ma machine
- Exécution sur plus de branches que par le passé (environ 20 branches avant l'arrêt du programme, soit à cause de la mémoire, soit à cause du processeur)
- Résultats obtenus sur 100 branches
- On vérifie que si l'exécution est stoppée manuellement, c'est que l'élève a potentiellement réalisé une boucle infinie, et on en gère l'exécution
- Le code fonctionne, mais il peut parfois s'arrêter sans aucune bonne raison apparente
- Plusieurs tentatives pour réduire l'espace mémoire utilisé par le programme, sans succès

*** TODO Récupérer une nouvelle machine
      SCHEDULED: <2015-07-06 mon.>
*** DONE Rendre le code propre dans toutes les classes déjà écrites
      SCHEDULED: <2015-06-18 thu.>
*** DONE Problème sur les leçons traitant de la récursivité
      SCHEDULED: <2015-06-18 thu.>
*** DONE Etudier la rétrocompatibilité du programme (exercices qui ont changé de nom...)
      SCHEDULED: <2015-06-19 fri.>
      Est-ce que ça a vraiment un intérêt, étant donné que ce sont, pour la plupart d'entre eux, des exercices qui n'existent plus actuellement dans la PLM ?
      Pour l'instant, ça ne fonctionne pas vraiment.
*** DONE Réaliser des tests sur de grandes masses de données
      SCHEDULED: <2015-06-19 fri.>
      Pour cela, il faut une machine plus puissante et surveiller l'exécution du code pendant toute sa durée, quitte à relancer le code plusieurs fois.
      Le test a été effectué sur 150 branches pour un total de près de 6600 fichiers.

** Thu 18 Jun

- Premiers tests de création d'un jar pour l'exécution à distance (ça fonctionne bien en console)
- Leçons sur la récursivité normalement toutes gérées
- Javadoc créée dans les classes qui concernent mon travail

*** DONE Commenter le code
      SCHEDULED: <2015-06-22 mon.>

** Fri 19 Jun

- Vérification approfondie des erreurs récupérées : certaines erreurs n'ont pas de consistance puisque l'exercice n'existe plus dans la PLM
- Refactoring du code terminé
- Fusion du code avec le code d'Hervé
- Jar prêt à être exécuté sous réserve de surveillance accrue
- Débug du code qui peut maintenant s'exécuter sur n'importe quelle machine possédant au moins 2Go de RAM disponible pour Java et un processeur lambda (joue sur la vitesse de calcul)

*** DONE Lancer le programme sur toutes les branches
      SCHEDULED: <2015-06-22 mon.>
*** DONE Créer un jar
      SCHEDULED: <2015-06-19 fri.>
*** DONE  Gérer les boucles infinies
      SCHEDULED: <2015-06-22 mon.>

* Week 22 Jun
** Mon 22 Jun

- Correction de quelques bugs sur l'exécution des exercices qui ont changé de nom
- Etude de la PLM pour l'implantation des mondes erreurs

*** DONE S'occuper de l'exécution des exercices sur la Moria
      SCHEDULED: <2015-06-22 mon.>
*** DONE Vérifier si les exercices à exécuter sont présents dans la liste des exercices encore implantés
      SCHEDULED: <2015-06-23 tue.>
*** DONE Créer un monde erreur
      SCHEDULED: <2015-06-22 mon.>
*** DONE Implanter le monde erreur et tester son exécution
      SCHEDULED: <2015-06-26 fri..>

** Tue 23 Jun

- Correction d'un bug dans le reparcours des branches
- Etude approfondie de la PLM

** Wed 24 Jun

- Nouvelle recorrection dans le reparcours des traces
- Accueil des deux nouveaux stagiaires
- Première tentative d'ajout de mondes leurre

** Thu 25 Jun

- Premiers mondes leurre ajoutés (il faut encore que ça affiche le bon message dans la PLM, et là, c'est une autre paire de manche...)
- Plusieurs essais réalisés, mais je ne sais pas si les mondes leurres sont testés ou non

*** DONE Vérifier que les mondes leurre sont compilés
      SCHEDULED: <2015-06-29 mon.>
*** TODO Faire afficher le bon message à la PLM
      SCHEDULED: <2015-07-02 thu.>

** Fri 26 Jun

- Les mondes leurre ne sont ni testés, ni compilés (il doit probablement y avoir quelque chose à faire avec getCompilableContent)
- Le code avance vers sa structure finale, il reste seulement à modifier quelques classes...

*** DONE Continuer de modifier les classes attenantes à l'ajout d'un test d'un monde leurre
     SCHEDULED: <2015-06-29 mon.>

* Week 29 Jun
** Mon 29 Jun

- Premier affichage du bon résultat mais problème au niveau de son obtention

** Tue 30 Jun

- Le code est committé dans mon repo forké de la PLM (http://www.github.com/Glasfeu/PLM)
- Il permet d'ajouter des mondes leurre en java, scala et python, mais affiche pour le moment la même erreur (voir TODO du 25 juin)
- Les trois langages suscités sont obligatoires pour qu'une erreur soit testée

*** DONE Utiliser la structure de Vector<Vector<World>> pour tester plusieurs résultats faux
      SCHEDULED: <2015-07-02 thu.>
*** TODO Trouver le moyen de changer le message qui s'affiche selon l'exercice lancé
      SCHEDULED: <2015-07-06 mon.>
*** TODO Réfléchir à la manière d'ajouter les mondes leurre dans la PLM
      SCHEDULED: <2015-07-07 tue.>

** Wed 1 Jul

- Avancée dans les deux premiers points du jour précédent

** Thu 2 Jul

- Utilisation possible de plusieurs fichiers leurre dans un exercice donné (il faut donner comme nom à ces fichiers <exo>CommonErr[0-9]* avec un ordre à respecter absolument (en gros, pas de fichier CommonErr3 sans un CommonErr0, 1 et 2))

*** DONE Vérifier les résultats de la réexecution des codes élèves (il y a des résultats étranges)
      SCHEDULED: <2015-07-06 mon.>
      Problème trouvé : le code élève n'est pas exécuté, donc évidemment, ça rend les choses un peu plus compliquées.
      Il y a eu un autre petit problème, une inversion entre deux mondes, mais le problème n'en est plus un.

** Fri 3 Jul

- Solution au problème : le programme n'a pas le temps de modifier le currentWorld. Du coup, il faut rajouter une méthode permettant d'attendre le runner de Game.java.
- Nouveau problème : les tests ont été effectués avec un Thread.sleep(x) avec x = 1000 (ne fonctionne pas) et x = 5000 (fonctionne parfois). On a plus de 48000 fichiers d'erreur. Un simple calcul nous donne une durée d'exécution comprise entre 13 heures 20 minutes et 66 heures et 40 minutes pour environ 1386 branches sur l'intervalle d'attente de 1 seconde à 5 secondes.
- Si la solution à ce problème est trouvée, il est possible de modifier l'implémentation de la gestion des boucles infinies, avec un timer. L'idée est de mesurer le temps que prend la solution à se compiler et s'exécuter et, à l'aide d'un facteur multiplicateur compris entre 1,1 et 2, estimer le temps avant le timeout pour le code de l'élève. Si ce temps est dépassé, on lui annonce gentillment que sa solution n'en est pas une dans un temps raisonnable.

*** TODO Régler les temps d'exécution pour la réexécution des codes élève
      SCHEDULED: <2015-07-06 mon.>
*** TODO Etudier la question des temps d'exécution pour les boucles infinies
      SCHEDULED: <2015-07-08 wed.>
